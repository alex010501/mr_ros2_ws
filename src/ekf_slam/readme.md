## Практическое задание №7
### Локализацие МР по особым точкам с помощью EKF SLAM

В этой задаче мы реализуем решение SLAM с помощью EKF (Extended Kalman Filter)

Будем рассматривать упрощенный вариант, когда в рабочей зоне находятся препятствия, легко выделяемые в скане дальномера (столбики или бочки), которые могут быть использованы как особые точки для локализации..
Общее число препятствий в рабочей зоне будем считать известным и заранее заданным (здесь их 12).

В этом проекте мы будем определять положение робота и маяков с помощью алгоритма EKF SLAM.

Результат (позиция робота и маяков) будет публиковаться для визуализации в rviz в виде соощений [geometry_msgs::msg::PoseStamped](https://docs.ros.org/en/api/geometry_msgs/html/msg/PoseStamped.html) (конфиг для rviz уже настроен для их отображения). Также будет публиковаться ветка дерева tf в виде трансоформа от системы координат лазерного дальномера до системы координат карты (map). Не наоборот, чтобы сохранить однонаправленность дерева трансформов: у нас уже есть трансформы, которые мы получаем от симулятора `odom->base_link->scan`. При идеальном определении положения робота будет публиковаться правильный трансформ и в rviz должно корректно отображаться положение робота и маяков при выборе fixed_frame = map.

В проекте потребуется реализовать функцию поиска и добавления маяков по скану дальномера, а также функцию обновления состояния в алгоритме EKF для каждого маяка.

### Описание проекта
Проект реализован в виде класса [Slam](./include/ekf_slam/slam.h). В классе хранятся различные объекты для работы с ROS (публикаторы результатов, tf броадкастер и пр.), Вектор состояния X, который в нашей задаче ханит позицию робота (x, y, угол) и положения всех маяков (x, y) (размерность 3 + 2 * 12), Матрица-якобиан системы - A, Матрица ковариации ошибок оценок - P. Матрица возмущений(шумов) системы R (3x3) и Q - матрица шумов измерения (2x2) каждого маяка.
new_landmarks - вектор с координатами маяков, найденных в текущем скане в СК дальномера.
last_found_landmark_index - индекс последнего найденного маяка. Эта переменная нужна для инициализации части состояния, относящейся к маяку, котрый мы видим первый раз.
Объект класса подписывается 
- на сообщения одометрии: [on_odo](./src/slam.cpp#L50) - сохраняет текущую угловую и линейную скорость..
- на сообщение дальномера: [on_scan](./src/slam.cpp#L289), в котором выполняется один цикл алгоритма EKF.
В конструкторе класса выполняется начальная инициализация, заполняются матрцы EKF: положение МР считается нулевым, с нулевой ковариацией, положение маяков неизвестны - соответстующие элементы матрицы ковариации заполняются большими значениями. Матрицы шумов системы и измерений заполняются параметрами из конфига (дефолтные значения выбраны разумными, но возможно потребуется настройка). Матрица ковариации шумов системы отображает неточность нашей модели движения МР, а матрица шумов системы - неточность определения координат маяков с помощью дальномера.

Алгоритм состоит из следующих шагов:
1. Определяем положение маяков в текущем скане ([detect_landmarks](./src/slam.cpp#L97)). В результате вектор new_landmarks должен быть заполнен координатами найденных маяков.
2. Шаг предсказания predict: выполняется шаг предсказания EKF на момент времени, относящийся к стемпу скана. На основе кинематической модели МР обновляется часть вектора состояния, относящаяся к кординатам робота, вычисляется якобиан системы и обновляется матрица ковариации системы. Эта функция [реализована](./src/slam.cpp#L413)
3. Для каждого найденного маяка ищем индекс соответствующего маяка в состоянии - [associate_measurement](./src/slam.cpp#L146). Эта функция реализована - она осуществляет поиск ближайшего маяка в состоянии (координаты маяков хранятся в векторе состояния последовательно, `X.segment(3 + i*2, 2)` - функция Eigen, возвращающая сегмент вектора состояния, относящийся к i-ому маяку). Если расстояние до ближайшего маяка меньше определенного порога, то считаем, что мы нашли индекс. Иначе возвращается -1.
4. Если маяк в скане - один из тех, которые мы уже видели (его координаты в стейте и матрица ковариации инициализирована), тогда производим коррекцию EKF по этому измерению (по одному маяку) - вызывается функция [correct](./src/slam.cpp#L239).
5. Если найденный маяк не имеет ассоциаций, то добавляем его в стейт: инициализирем начальное положение координатами маяка в СК карты и соответствующие элементы матрицы ковариации - [add_landmark_to_state](./src/slam.cpp#L170).
6. В конце публикуются результаты и трансформ в tf.

### Запуск
Запуск осуществляется с помощью команды:
```bash
sudo bash task7.bash 
```
Запустится симулятор, контроллер для движения МР по заданному треку, модуль EKF SLAM - barrel_slam и rviz для визуализации маяков и робота.